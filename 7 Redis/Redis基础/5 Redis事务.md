# `Redis`事务

> 不同于`MySQL`的**多线程服务端**可以**同一时间处理多个客户端**发起的请求.`Redis-server`服务端是一个**单线程**设计,也就是说在**任意时刻`Redis-server`服务端能且仅能处理某一个客户端发起的请求**.,如果某一个客户端发起的**请求执行的很慢**,那么**所有的其他客户端**都**必须等待其执行完毕**.

- 从工作原理上保证的**严格事务`隔离性`**
    - 不同于`MySQL`事务的每一条语句在发送给服务端之后就会被尽可能快地执行,**`Redis`的事务中的所有语句在我们结束事务声明之前**都是**不会实际执行**的,`Redis-server`服务端会**一直等待**我们给出**事务终止指令**,然后`Redis-server`服务端就会**将我们声明的事务中的所有语句依次连续地执行**,也就是说`Redis`的事务从其实现方式上**根本地保证了事务的隔离性**
- **不保证事务`原子性`**
    - 不同于`MySQL`的事务,任何一条事务中的语句没有正确执行都会导致整个事务终止执行,并且事务中的所有语句产生的改变回滚,**`Redis`事务是没有回滚**的,并且**即便事务中存在语句报错**,**事务的执行也不会终止其他的语句依旧会正常执行**.

> **注意**:**有些指令当我们添加到我们的事务中时**,会**导致出错**,而恰巧我们的`Redis-server`会对我们的`Redis-client`添加的每一条事务内语句进行语法检查,如果**语法正确**`Redis-server`会**告知客户端`QUEUE`**,如果**语法出现问题**,那么就会**告知客户端语法出现了问题**.虽然我们**依然能够继续添加命令**,并且**调用`EXEC`**来要求我们的`Redis-server`执行我们的这个事务,但是**`Redis-server`在收到`EXEC`命令后会立马告知我们的客户端我们的事务中有语句语法是错误的,无法执行**,也就是说我们的这个事务**从始至终**都**不会被**我们的`Redis-server`服务端**真正执行**.
>
> ![image-20230309040405332](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303090404370.png)
>
> - **例如**
>     - `set k3`:没有给出`Value`值导致报错
>     - `dasdas`未知意义的命令导致报错

# `Multi`命令

> 声明事务的开始

# `Exec`命令

> 声明事务的结束,并将事务提交给`Redis-server`服务端

# `Discard`命令

> 用于`Multi`执行之后`Exec`执行之前,作用为取消当前事务清空为当前事务给出的所有指令.

# `Watch`命令

> 我们知道,当我们使用了`Multi`指令告诉`Redis-server`服务端我们在声明事务时,`Redis-server`仅仅只会将我们的事务语句按序记录下来,只有当我们调用`Exec`命令时,我们的`Redis-server`才会去找合适的时机一次性连续地将我们事务中的所有语句执行完毕.
>
> 但是我们考虑这样一种场景,我们在`Redis`数据库中存储了
>
> 此时我们的`Watch`命令就可以展现出其作用了

**作用**

- 我们可以**在使用`Multi`开启我们的事务之前**使用`Watch Key1名 Key2名`的方式让我们的`Redis-server`**监控为我们的当前客户端监控指定的一个或多个`Key`的值**,**只要**在我们**开启了监控之后**对应的`Key`中**有一个或以上发生了修改**,那么**此后的我们当前客户端发起的第一个**`Multi Exec`声明的事务**被`Redis-server`执行之前**都会**被直接打断**,**终止执行**并**返回`Nil`**,紧接着我们前面**调用`Watch`给我们当前客户端设置的所有监控都会被取消**.

```shell
WATCH Key1名 Key2名 Key3名
```



# `Unwatch`命令
