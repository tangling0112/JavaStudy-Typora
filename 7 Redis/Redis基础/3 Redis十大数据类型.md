# `Redis7`的十大数据类型汇总

- `String`字符串
- `List`列表
    - 底层为**双端链表**
- `Hash`哈希表
- `Set`集合
    - 同`Python`的`Set`
- `SorterSet`有序集合
- `Geospatial`地理空间
    - 存储经纬度
- `Hyperlog`基数统计
    - 
- `Bitmap`位图
    - 一个二进制数组,每一个元素只能存储`0/1`
- `Bitfield`位域
- `Stream`流

# `Redis7`键(`Key`)相关命令

|                命令                |                             作用                             |
| :--------------------------------: | :----------------------------------------------------------: |
|   `select Redis数据库索引[0-15]`   | 切换到指定`Redis`数据库<br />![image-20230303155132981](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031551014.png) |
|              `keys *`              | 查看**当前`Redis`数据库下**所有的`Key`<br />![](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031535924.png) |
|           `exists key名`           | 查看**当前`Redis`数据库下**指定`key`是否存在<br />![image-20230303153812286](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031538318.png) |
|            `type key名`            | 查看**当前`Redis`数据库下**指定`key`所对应的`value`的`Redis类型`<br />![image-20230303154022816](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031540851.png) |
|            `del key名`             | 删除**当前`Redis`数据库下**指定`Key Value`键值对<br />![image-20230303154129146](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031541180.png) |
|           `unlink key名`           | 非阻塞式地删除**当前`Redis`数据库下**指定`Key Value`键值对<br />![image-20230303154315017](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031543047.png) |
|        `expire key名 秒数`         | 为**当前`Redis`数据库下**指定`Key Value`键值对设置过期时间,单位为秒<br />![image-20230303154806028](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031548063.png) |
|            `ttl key名`             | 查看**当前`Redis`数据库下**指定`Key Value`键值对的剩余有效期,`-1`表示永不过期,`-2`表示已经过期,正数表示剩余有效期<br />![image-20230303154527397](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031545428.png) |
| `move key名 Redis数据库索引[0-15]` | 将指定`Key Value`键值对从当前`Redis`数据库转移到指定`Redis`数据库<br />![image-20230303155306433](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031553469.png) |
|              `dbsize`              | 查看**当前`Redis`数据库**下 拥有的`Key Value`键值对的数目<br />![image-20230303155447724](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031554753.png) |
|             `flushdb`              | 清空当前`Redis`数据库<br />![image-20230303155840385](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031558420.png) |
|             `flushall`             | 清空所有`Redis`数据库<br />![image-20230303155949085](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303031559120.png) |

# `String`字符串数据类型

## `String`类型特性介绍

## `String`类型相关命令

### `SET`命令

> #### 作用
>
> - **给当前数据库设置一个`Key Value`键值对**
>     - 当`Key`在当前数据库**不存在**时,会创建对应的`Key`
>     - 当`Key`在当前数据库**存在**时,会覆盖掉原本的`Key Value`键值对,**默认情况下**原本键值对对于`TTL`**过期时间的设置会被清除**

```shell
set key value [NX|XX] [EX 秒数|PX 毫秒数|EXAT 秒级时间戳|PXAT 毫秒级时间戳|KEEPTTL]
```

- **`NX`/`XX`**
    - `NX`:如果数据库中**存在**当前`Key`对应的`Key Value`键值对,那么我们的这次`SET`操作**不会执行**
    - `XX`:如果数据库中**不存在**当前`Key`对应的`Key Value`键值对,那么我们的这次`SET`操作**不会执行**
- **`EX 秒数`/`PX 毫秒数`**
    - 设置我们创建的这个`Key Value`键值对的有效时间长度
- **`EXAT 秒级时间戳`/`PXAT 毫秒级时间戳`**
    - 设置我们创建的这个`Key Value`键值对的有效时间的截止日期
- **`KEEPTTL`**
    - 前面我们提到原有`Key Value`键值对的`TTL`会被清除,借助`KEEPTTL`可以使得`TTL`不清除,而是继承到当前创建的`Key Value`键值对

### `SetRange`命令

> **作用**
>
> - 用于从指定偏移量位置之后开始给一个`Key Value`键值对**覆写**值,**注意是覆写值,不是插入值**
>     - ![image-20230304132934703](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041329855.png)
> - 假设**原字符串的长度为`x`**,我们给出的**偏移量为`y`**,那么会有以下几种情况
>     - :one:`x≥y`:此时就会在原字符串的第`y`个字符之后的字符**开始覆写**
>     - :two:`x<y`:此时我们可以理解为先用`"\x00"`将原字符串填充到`y`长度然后**再进行写入**

```shell
SetRange Key名 偏移量 要插入的值
```

> **注意**
>
> - 如果我们指定的这个`Key Value`键值对并**没有存储**在我们的当前**数据库中**,我们的这个操作**也会正常执行**
>     - 我们可以理解为我们的数据库中出现了一个`Key Value`键值对,这个键值对的`Value`是一个**空字符串**,然后我们的`SetRange`**根据**这个**空字符串进行插入**(**只是可以这样理解,不代表底层是这样实现**)
> - **注意是覆写值,不是插入值**

### `MSet`命令

> #### 作用
>
> - **同时**给当前数据库**设置多个`Key Value`键值对**
>     - 当`Key`在当前数据库**不存在**时,会创建对应的`Key`
>     - 当`Key`在当前数据库**存在**时,会覆盖掉原本的`Key Value`键值对,**默认情况下**原本键值对对于`TTL`**过期时间的设置会被清除**
> - **注意**:当**使用`MSETNX`命令**时,相较于`MSET`而言只要我们设置的**任何一个键值对的键**在我们的数据库中原始**存在**,那么我们的`MSETNX`操作就**不会执行**.只有当**每一个键都不出现**在原始数据库中时才会**顺利执行**.

```shell
MSET k1 tangling k2 hello k3 loving
```

> **注意**:**`MSET`是一个原子操作**,也就是说**只有**当我们使用`MSET`设置的**所有键值对操作完成**,我们的`MSET`**才算完成**.如果**存在任何一个没有正确完成**,我们的`MSET`都会**回滚到没有执行之前的状态**.

****

### `GET`命令

> **作用**
>
> - 根据指定的一个`Key`获取其相对应的`Key Value`键值对的`Value`值

```shell
get Key名
```

> **注意**
>
> - 如果指定的`Key Value`键值对**不存在**,那么**返回`nil`**,如果**存在**则返回其**`Value`值**
> - 如果我们的`Key Value`键值对的值**不是`String`字符串**类型,那么我们的**命令会报错**.

### `GetRange`命令

> **作用**
>
> - 用于获取指定`Key Value`键值对的`Value`值的指定区间内的子字符串(**效果类似于`Python`的字符串`[]`切片**)

```shell
GetRange Key名 开始位置 结束位置
```

> **注意**
>
> - 与`Python`字符串切片的不同在于
>     - :one:`GetRange`下获取到的子字符串是**包括区间右边界的字符**的
>         - `tangling`在`Python`中`[0:2]`的结果为`ta`
>         - 在`GetRange`下的结果为`tan`
>     - :two:在`Python`中可以不给出左右边界之一或者都不给出,编译器默认为字符串的开头和结尾
>         - 但是**在`GetRange`下则必须给出左右边界**
>     - :three:和`Python`一样可以**用`-x`表示倒数第`x`个字符**

### `MGET`命令

> **作用**
>
> - 根据指定的多个`Key`获取它们相对应的`Key Value`键值对的`Value`值

```shell
MGET k1 k2 k3
```

> **注意**
>
> - **不同**于`MSET`的原子性,如果我们的`MGET`指定的`Key`所指示的`Key Value`键值对中存在有一个或多个并没有存储在我们的数据库当中的时候,那么这些`Key Value`键值对对应的**返回值为`nil`**,其他的`Key`则**正常地返回其值**
> - 如果我们的某个`Key`对应的`Value`**不是`String`字符串类型**的,那么也**只是这一项报错**,**不会影响**到其他`Key Value`键值对的获取

****

### `GETSET`命令

> **作用**
>
> - 效果相同于**先执行`get Key名`再执行`set Key名 Value`**
> - 只不过**这样是一个原子操作具备事务的完整性**

****

### `INCR`命令

> **作用**
>
> - 为我们指定的`Key Value`键值对的`Value`**加**`1`

```shell
INCR Key名
```

> **注意**
>
> - `Redis`为`INCR`添加了判定,如果我们的`Value`**确实使用字符串存储的数值**,那么操作会**正确执行**,但是如果**不是数值**,那么会**直接报错**
>     - ![image-20230304134638044](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041346089.png)
> - 如果我们指定的`Key Value`键值对**不存在**,那么会**先创建**一个`Value=0`的键值对,**然后**对这个键值对**进行`Value+1`操作**

### `INCRBY`命令

> **作用**
>
> - 为我们指定的`Key Value`键值对的`Value`**加**上**指定的整数值**
>     - ![image-20230304135131681](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041351720.png)

```shell
INCRBY Key名 整数增量
```

### `INCRBYFLOAT`命令

> 作用
>
> - 为我们指定的`Key Value`键值对的`Value`**加**上**指定的浮点数值**
>     - ![image-20230304135209004](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041352039.png)

```shell
INCRBTFLOAT Key名 浮点数增量
```

****

### `DECR`命令

> **作用**
>
> - 为我们指定的`Key Value`键值对的`Value`**减**`1`

```shell
DECR Key名
```

> **注意事项同`INCR`**

### `DECRBY`命令

> **作用**
>
> - 为我们指定的`Key Value`键值对的`Value`**减去**指定整数减量

```shell
DECRBY Key名 整数减量
```

### `DECRBYFLOAT`命令

> **作用**
>
> - 为我们指定的`Key Value`键值对的`Value`**减去**指定浮点数减量

```shell
DECRBY Key名 浮点数减量
```

****

### `APPEND`命令

> **作用**
>
> - 用于在指定的`Key Value`键值对的`Value`值的末尾添加上指定的字符串

```shell
APPEND Key名 字符串
```

> **注意**
>
> - 如果`Key Value`键值对不存在,那么效果与`SET Key名 字符串`相同

****

### `StrLen`命令

> 作用
>
> - 获取指定`Key Value`键值对的`Value`值对应的字符串的长度

```shell
StrLen Key名
```

# `List`列表数据类型

## `List`列表类型的特性介绍

> **底层为双端链表**

## `List`列表类型相关命令

### `LPush`命令

> **作用**
>
> - 用于从我们指定的`Key Value`键值对的`Value`值这个**双端链表的头部**依**次从左到右**插入一个或多个元素

```shell
LPUSH Key名 元素1 元素2 元素3
```

> **注意**
>
> - 插入时是**从头部插入**,并且是按照我们给出的元素**依次从左到右插入**.因此如果原本`Value`为`[元素0]`,那么**插入的结果为`[元素3,元素2,元素1,元素0]`**
> - 如果我们对应的`Key Value`键值对**不存在**,那么会先**创建**一个`Key Value`键值对,并且`Value`为一个**空的双端链表**,然后**再执行插入操作**
> - 如果我们的`Key Value`键值对**存在**,但`Value`**不是`Redis List`数据类型**,那么会**报错**

### `LPushX`命令

> **作用**
>
> - 当指定的`Key Value`此时**已经存储在**当前数据库中,**并且**`Value`是**`Redis List`数据类型**时,效果**与`LPUSH`相同**
> - 但是如果此时`Key Value`键值对**没有存储**在当前数据库中,那么这个命令就会**失效**,**类似于`SETX`**

```shell
LPUSHX Key名 元素1 元素2 元素3
```

****

### `RPush`命令

> **作用**
>
> - 与`LPUSH`类似,只不过**不是**从双端链表的**头部插入**,而**是尾部插入**

```shell
RPUSH Key名 元素1 元素2 元素3
```

### `RPushX`命令

> **作用**
>
> - **与`LPUSHX`是一个道理**,只有**当`Key Value`键值对存在且`Value`为`Redis List`数据类型时才有效**

```shell
RPUSHX Key名 元素1 元素2 元素3
```

****

### `LPop`命令

> **作用**
>
> - 用于**获取并移除**指定的`Redis List`数据类型`Key Value`键值对这个双端链表的头部元素

```shell
LPOP Key名
```

> **注意**
>
> - 如果`Key Value`键值对的`Value`**不是`Redis List`数据类型**,那么就会**报错**
> - 如果`Key Value`键值对**并不存在**,那么会**返回`Nil`**
> - 如果`LPOP`之后`Key Value`键值对的`Value`双端链表中**没有元素了**,那么`Redis`会**自动清除**这个`Key Value`键值对

### `BLPop`命令

> **作用**
>
> - **阻塞式地执行`LPop`命令**,如果命令**没有执行成功**,那么我们的`Redis`就会**一直阻塞**,知道我们的这个命令**超时或执行成功**.

```shell
BLPOP Key名
```

****

### `RPop`命令

> **作用**
>
> - **类似于`LPop`,只不过是获取并删除尾部的元素**

```shell
RPOP Key名
```

### `BRPop`命令

> **作用**
>
> - **阻塞式地执行`RPop`命令**,如果命令**没有执行成功**,那么我们的`Redis`就**会一直阻塞**,**直到**我们的这个命令**超时或执行成功**.

```shell
BRPOP Key名
```

****

### `RPopLPush`命令

> **作用**
>
> - 用于从指定的`Key1 Value`键值对对应的**双端链表的尾部获取并移除一个元素**,然后再将这个获取到的元素**插入**到指定的`Key2 Value`键值对对应的**双端链表的头部**.并且**返回值**会告诉你获取到的**元素的值**

```shell
RPopLpush Key1名 Key2名
```

> **注意**
>
> - `RPopLPush`命令的设计原因在于其**是一个原子操作,遵循事务完整性**.而先执行`RPop`再执行`LPush`由于涉及到两个命令,**不是原子操作,无法遵循事务的完整性**
> - 我们的`RPopLPush`的**两个参数可以指向同一个`Key Value`键值对**,这样的效果就是我们**把列表的尾部元素移动到了头部**.并且我们还**通过返回值获取到了这个元素的值**
>     - **无论是遍历列表,还是翻转列表,这都是一个可靠高效的实现方式**

### `BRPopLPush`命令

> **作用**
>
> - **阻塞式**地执行`RPopLPush`命令

****

### `LRem`命令

> **作用**
>
> - 用于移除我们的`Key Value`键值对对应的双端链表中的`Value`值与我们指定的一个值相等的最多指定个数个元素

```shell
LREM Key名 要移除的数目 要移除的值
```

> **注意**
>
> - 要移除的数目可以是以下的几种
>     - :one:**大于`0`**,从**表头开始向表尾**依次搜索**最多**删除指定个数个元素
>     - **:two:小于`0`**,从**表尾开始向表头**依次搜索**最多**删除指定个数个元素
>     - :three:**等于`0`**,删除**所有的**
> - 如果我们的`Key Value`键值对对应的双端链表中**只有`x`个**指定元素,但是我们**设置要移除的数目为`y`**.`**x<y**`,那么就**只会删除`x`个.**
>     - **也就是说`x,y`两者取其小**

### `LLen`命令

> **作用**
>
> - 用于获取指定`Key Value`键值对对应的双端链表中的元素的数目

```shell
LLEN Key名
```

> **注意**
>
> - 如果指定的`Key Value`键值对并**不存在**,那么**返回`0`**
> - 如果`Key Value`键值对的`Value`**不是`Redis List`类型则报错**

### `LIndex`命令

> **作用**
>
> - 用于获取`Key Value`键值对对应的双端链表的**指定位置的某个元素**.(效果**与`Python`的`list`列表取值几乎相同**)

```shell
LINDEX Key名 索引值
```

> **注意**
>
> - **不同**于`Python`的`list`列表取值在给出超出列表区间范围的索引时会**爆出越界异常**,**`LIndex`下这种情况只是会返回`Nil`.**

### `LRange`命令

> **作用**
>
> - 用于获取`Key Value`键值对对应的双端链表的**指定区间内的一些元素**.(效果**与`Python`的`list`列表切片几乎相同**)

```shell
LRANGE Key名 开始索引 结束索引
```

> **注意**
>
> - `LRange`与`Python`的`list`列表切片的区别与`GetRange`与`Python`**字符串切片的区别一致**
> - 不同于`Python`当我们给出的区间范围大于我们的`list`列表实际的范围时会**爆出越界异常**,我们的`LRange`对此有着**特殊的机制**
>     - 当我们的`开始索引`**大于等于**我们的`Redis List`中的元素数目时,**返回一个`empty array`**
>     - 当我们的`开始索引`和`结束索引`都**小于**我们的`Redis List`中的元素数目,**正常运作**
>     - 当我们的`开始索引`**小于**我们的`Redis List`中的元素数目,但结束索引**大于等于**我们的`Redis List`中的元素数目时,`Redis`会自动**以`结束索引=元素总数-1`来进行切片**

### `LInsert`命令

![image-20230304165846302](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041658368.png)

```shell
LINSERT Key名 Before 值1 值2
LINSERT Key名 After 值1 值2
```

### `LSet`命令

> **作用**
>
> - 用于修改`Key Value`键值对对应的双端链表的指定元素的值

```shell
LSET Key名 索引 新值
```

> **注意**
>
> - `Key Value`**键值对不存在**,或者给出的**索引超出范围**,或者`Key Value`键值对存在但**不是`Redis List`类型**时**都会直接报错**

### `LTrim`命令

> 作用
>
> - 用于只保留`Key Value`键值对对应的双端链表中我们给出的范围内的元素

```shell
LTRIM Key名 开始索引 结束索引
```

# `Hash`哈希表数据类型

## `Hash`哈希表数据类型的特性介绍

## `Hash`哈希表相关命令

### `HSet`命令

> **作用**
>
> - 用于**修改**指定哈希表中**指定一个的`Key`的`Value`值**

```shell
HSET 哈希表名 Key Value	
```

> **注意**
>
> - 若我们的**哈希表不存在**,那么就会**新建一个哈希表**然后**再执行`HSet`命令**
>
> - 若当前哈希表中`Key`**已经存在**,那么就会用我们给出的`Value`**覆盖原来的值**.并且**返回`0`**
> - 若当前哈希表中`Key`**尚未存在**,那么就会将我们给出的**`Key Value`存入这个哈希表**.并且**返回`1`**

### `HMSet`命令

> **作用**
>
> - 用于**同时修改**指定哈希表中的**指定的多个`Key`的`Value`值**

```shell
HMSET 哈希表名 Key1 Value1 Key2 Value2 Key3 Value3
```

> **注意**
>
> - 这个操作**具备原子性**(就是我们在`MSET`那里谈到的原子性)
> - 如果指定的`Key`**不存在**,那么就会将该`Key Value`键值对**存入这个哈希表**
> - 如果指定的`Key`**存在**,那么就会用我们给出的`Value`值**覆盖掉该`Key`原有的`Value`值**

### `HSetNX`命令

> **作用**
>
> - 类似于我们的`SETNX`,**只有**当我们的哈希表中我们指定的这个`Key Value`键值对**不存在时才会执行**,如果**存在**那么这个**命令直接失效**

```shell
HSETNX 哈希表名 Key Value
```

****

### `HGet`命令

> **作用**
>
> - 用于获取**指定哈希表**中**指定的一个`Key`对应的`Value`值**

```shell
HGET 哈希表名 Key
```

> **注意**
>
> - 如果**哈希表不存在**或者对应的`Key Value`键值对并**没有在我们的哈希表中**,那么我们的命令会**返回`Nil`**

### `HMGet`命令

> **作用**
>
> - 用于获取**指定的哈希表**中**指定的一些`Key`所对应的`Value`值**

```shell
HMGET 哈希表名 Key1 Key2
```

> **注意**
>
> - 若我们的哈希表中`Key`对应的`KV`**键值对存在**,那么就**返回其`Value`值**,如果对应的`KV`**键值对不存在**,那么就**返回`Nil`**
>
> - 若我们给出的**哈希表不存在**,那么就相当于我们的**用`HMGet`去操作一张空哈希表**,得到的会是**多个`Nil`**

### `HGetAll`命令

> **作用**
>
> - 获取指定哈希表中的所有`Key Value`键值对
>     - ![image-20230304183527821](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303041835906.png)

```shell
HGETALL 哈希表名
```

****

### `HExists`命令

> **作用**
>
> - 用于查看指定的哈希表中是否存在指定的`Key Value`键值对

```shell
HEXISTS 哈希表名 Key
```

> **注意**
>
> - 若**哈希表存在且是`Redis Hash`数据类型**,那么分为以下两种情况
>     - 指定的`Key`对应的`Key Value`键值对**存在**,返回**`1`**
>     - 指定的`Key`对应的`Key Value`键值对**不存在**,返回**`0`**
> - 若**哈希表不存在**,那么返回值**恒为`0`**
> - 若**哈希表名存在**但**不是`Redis Hash`数据类型**,那么**直接报错**

### `HDel`命令

> **作用**
>
> - 用于**根据`Key`**删除指定哈希表中的**一个或多个**指定`Key Value`键值对

```shell
HDEL 哈希表名 Key1 Key2 Key3
```

> **注意**
>
> - 如果指定的哈希表**不存在**,那么**返回`0`**
> - 如果指定的哈希表**存在**,那么**返回成功删除的`Key Value`键值对的数目**
> - 当我们指定的`Key`并**没有出现在我们的哈希表中**的时候**不会报错**,而**是不作为**.
> - 如果经过我们的**删除之后哈希表中没有元素了**,那么这个**哈希表**就会**被**我们的`Redis`自动删除

### `HLen`命令

> **作用**
>
> - 用于获取指定的哈希表中的`Key Value`键值对的数目

```shell
HLEN 哈希表名
```

> **注意**
>
> - 若我们的哈希表并不存在，那么返回`0`

### `HStrLen`命令

> **作用**
>
> - 获取我们**指定的哈希表**中的**指定`Key Value`键值对**的`Value`值的**字符串的长度**

```shell
HSTRLEN 哈希表名 Key
```

> **注意**
>
> - 我们的`Redis Hash`数据类型中**`Key`与`Value`都是用字符串存储的**
> - 如果我们指定的这个**`Key Value`键值对不存在**,或者我们的**哈希表不存在**,那么**返回`0`**

### `HKeys`命令

> **作用**
>
> - 获取指定哈希表中的**所有`Key`**

```shell
HKEYS 哈希表名
```

> **注意**
>
> - 如果**哈希表并不存在**那么**返回`empty array`**

### `HVals`命令

> **作用**
>
> - 返回指定的哈希表中的**所有`Value`**

```shell
HVALS 哈希表名
```

> **注意**
>
> - 若该**哈希表并不存在**,那么**返回`empty array`**

### `HIncrBy`命令

> **作用**
>
> - 给**指定的哈希表**中的**指定的`Key Value`键值对**的`Value`值加上指定的**整数数值**

```shell
HINCRBY 哈希表名 Key 整数增量
```

> **注意**
>
> - 若我们的这个`Key Value`键值对的`Value`并**不能被转换为十进制的数字**,那么我们的**操作会导致直接报错**(类似于我们的字符串的`INCR|INCRBY`命令)
> - 若哈希表不存在就会创建哈希表并创建`Key Value`键值对然后再执行`HINCRBY`
> - 若`Key Value`键值对不存在就会先创建然后再执行`HINCRBY`

### `HIncrByFloat`命令

> **作用**
>
> - 和`HINCRBY`基本相同,只是`HINCRBY`只能设置整数增量,而`HINCRBYFLOAT`可以设置浮点数增量

```shell
HINCRBYFLOAT 哈希表名 Key 浮点数增量
```

### `HScan`命令

# `Set`集合数据类型

## `Set`集合数据类型的特性

## `Set`集合数据类型的相关命令

### `SAdd`命令

> **作用**
>
> - 向**指定的集合**中**添加一个或多个元素,**返回**成功添加**到集合中的**元素的数目**

```shell
SADD 集合名 元素1 元素2 元素3
```

> **注意**
>
> - 若集合**不存在**,那么会先**创建一个空集合**,然后**再添加**
> - 若**某个元素已经存在**了,那么如果我们**添加的某个元素与这个元素相等**,那么这个元素**不会被重复添加**,也就是说这个元素的**添加操作会被忽略掉**

### `SIsMember`命令

> **作用**
>
> - 用于查看指定集合中**是否存在指定元素**,**存在**返回**`1`**,不存在返回**`0`**

```shell
SISMEMBER 集合名 元素
```

> **注意**
>
> - 如果我们的**集合不存在**,那么**返回值恒为`0`**

### `SPop`命令

> **作用**
>
> - 用于**随机获取**指定集合中的**一个或多个元素**.这些元素在**被成功获取后**会被**从集合中移除**

```shell
SPOP 集合名 count
```

> **注意**
>
> - 若集合并**不存在**,那么**返回`Nil`**

### `SRandMember`命令

> **作用**
>
> - 作用**与`SPop`基本相同**,只不过`SRandMember`**不会**将被获取的元素**从集合中移除**

```shell
SRANDMEMBER 集合名 count
```

> **注意**
>
> - 

### `SRem`命令

> **作用**
>
> - 用于**删除**指定集合中的**指定的一个或一些元素**,**返回值为成功删除掉的元素数**

```shell
SREM 集合名 元素1 元素2 元素3
```

> **注意**
>
> - 若**集合不存在**,那么命令**不做任何操作**,并**返回`0`**
> - 若**集合存在**,但是**要删除的元素中有些不在集合中**,那么这些元素**就会被忽略**,返回值是**只包括成功删除的元素** **不包括被忽略的元素的**

### `SMove`命令

> **作用**
>
> - 用于从指定集合中**将指定元素移除**,并**同时**将该元素**存入另一个指定集合**

```shell
SMOVE 集合1 集合2 元素
```

> **注意**
>
> - 若元素在**集合`1`中不存在**,那么我们的`SMove`**什么也不会做**,最终**返回`0`**
> - 若元素在**集合`1`中存在**,在**集合`2`中不存在**,那么就会正常执行,**返回`1`**
> - 若元素在**集合`1`中存在**,在**集合`2`中也存在**,那么就**只会移除集合`1`中的这个元素**,然后**什么也不做**,**返回`1`**

### `SCard`命令

> **作用**
>
> - 用于获取指定集合中的**元素的数量**

```shell
SCARD 集合名
```

> **注意**
>
> - 若集合**不存在**,则**返回`0`**

### `SMembers`命令

> **作用**
>
> - **获取集合中所有的元素**

```shell
SMEMBERS 集合名
```

> **注意**
>
> - 如果**集合不存在**则**返回`empty array`**

### 交集

#### `SInter`命令

> **作用**
>
> - 获取指定的一些集合的**交集**,**返回值为这个交集**

```shell
SINTER 集合1 集合2 集合3
```

> **注意**
>
> - 若存在**某个集合不存在**,那么`SInter`的返回值根据交集的规则**返回`empty array`**

#### `SInterStore`命令

> **作用**
>
> - 作用**与`SInter`一致**,只不过其会把获取到的交集**存储到指定的集合中**

```Shell
SINTERSTORE 存储集合 集合1 集合2 集合3 
```

> **注意**
>
> - 若我们的**存储集合是已经存在的集合**,那么`Redis`会先**把这个集合清空**,然后**再把**我们获取到的这个交集中的**元素存储到这个存储集合**中

### 并集

#### `SUnion`命令

#### `SUnionStore`命令

### 差集

#### `SDiff`命令

#### `SDiffStore`命令

# `SortedSet`有序集合数据类型

## `SortedSet`有序集合数据类型特性介绍

- :one:有序集合中元素的存储顺序**并不是按照我们插入的顺序排列**的,我们每插入一个元素我们的有序集合就会做一次重构,**最终保证**元素**分数越小的**元素**越靠近头部**,元素**分数越大的**元素**越靠近尾部**

## `SortedSet`有序集合相关命令

### `ZAdd`命令

> **作用**
>
> - 用于向指定的一个有序集合中**添加一个或多个元素**

```shell
ZADD 有序集合名 [NX|XX] [GT|LT] [CH] [INCR] 元素1分数 元素1 元素2分数 元素2 元素3分数 元素3
```

> **注意**
>
> - 若**有序集合不存在**,那么就会**创建一个空的**有序集合然后**再执行`ZAdd`命令**
> - 若给出的某个元素**已经存在**于有序集合中,那么用我们**新给出的元素分数**来**更新**该元素的**原本的元素分数**
> - **元素分数**可以**是一个整数**或者**一个双精度浮点数**

### `ZScore`命令

> **作用**
>
> - 获取指定的一个有序集合中**指定元素的元素分数**

```shell
ZSCORE 有序集合名 元素
```

> **注意**
>
> - 若**有序集合不存在**或者**有序集合存在**但**元素不在**该集合中,那么会**返回`Nil`**

### `ZIncrBy`命令

> **作用**
>
> - 用于给**指定的一个有序集合**中的**指定元素**的**元素分数增加指定增量**

```shell
ZINCRBY 有序集合名 增量 元素
```

> **注意**
>
> - 不同于`HINCR`以及`INCR`命令**只能指定整数增量**,`ZIncrBy`可以**指定整数或双精度浮点数增量**
> - 若**有序集合不存在**,那么就会先**构建一个空的有序集合**,然后再往该有序集合中**自动添加我们指定的这个元素**,这个元素的**`SCORE=0`**,然后**再执行我们的`ZIncrBy`命令**
> - 若**有序集合存在**,但**元素不在**该有序集合中,那么就会自动向该有序集合中**添加该元素**,并且**`SCORE=0`**,然后**再执行`ZIncrBy`命令**

****

### `ZCard`命令

> **作用**
>
> - 用于获取指定的一个有序集合中的**元素的数目**

```shell
ZCARD 有序集合名
```

> **注意**
>
> - 若**有序集合不存在**,那么**返回`0`**

### `ZCount`命令

> **作用**
>
> - 用户获取指定的一个有序集合中**元素分数处于闭区间**`[区间左值,区间右值]`中的**元素的数目**

```shell
ZCOUNT 有序集合名 区间左值 区间右值
```

> **注意**
>
> - 若**有序集合不存在**,那么**返回`0`**

****

### 按索引切片

#### `ZRange`命令

> **作用**
>
> - 获取指定的一个有序集合中**指定索引区间内的元素**

```shell
ZRANGE 有序集合名 开始索引 结束索引 [WITHSCORES] [LIMIT 偏移量 最多获取的元素数]
```

> **注意**
>
> - 默认获取到的**只有元素没有元素分数**,如果我们**指定`WITHSCORES`**那么就还会给我们**一并返回元素的元素分数**,**格式为`元素1 元素1分数 元素2 元素2分数`**

#### `ZRevRange`命令

> **作用**
>
> - **几乎与`ZRange`相同**,只不过获取到的元素**从根据元素分数从小到大排序**变为了**根据元素分数从大到小排序**

```shell
ZREVRANGE 有序集合名 开始索引 结束索引 [WITHSCORES] [LIMIT 偏移量 最多获取的元素数]
```

****

### 按元素分数切片

#### `ZRangeByScore`命令

> **作用**
>
> - 用于获取指定的一个有序集合内**所有元素分数位于给定取值区间内的元素**,获取到的元素**按照**其**元素分数从小到大排序**

```Shell
ZRANGEBYSCORE 有序集合名 区间左值 区间右值 [WITHSCORES] [LIMIT 偏移量 最多获取的元素数]
```

> **注意**
>
> - 我们的给出了区间左值与区间右值后,我们的`ZRangeByScore`命令**默认使用闭区间**`[区间左值,区间右值]`去**根据元素分数获取元素的**
>     - 但实际上我们可以通过
>         - `(区间左值 区间右值`
>         - `(区间左值 (区间右值`
>         - `区间左值 (区间右值`
>     - 将**取值区间转变**为
>         - **左开右闭**`(区间左值,区间右值]`
>         - **开区间**`(区间左值,区间右值)`
>         - **左闭右开**`[区间左值,区间右值)`

#### `ZRevRangeByScore`命令

> **作用**
>
> - 几乎与`ZRangeByScore`相同,**只不过**获取到的元素变为了**按照元素分数从大到小排序**

```shell
ZREVRANGEBYSCORE 有序集合名 区间左值 区间右值 [WITHSCORES] [LIMIT 偏移量 最多获取的元素数]
```

****

### 特殊切片

#### `ZRangeByLex`命令

****

### `ZRank`命令

> **作用**
>
> - 用于获取指定的一个有序集合中指定元素的排名

```shell
ZRANK 有序集合名 元素
```

> **注意**
>
> - 若**有序集合不存在**,或者**存在但是元素不在**这个有序集合中,那么会**返回`Nil`**
> - `ZRank`的排名是按照元素分数**从小到大排序**的,也就是说**元素分数越小**的元素**排名越靠前**

### `ZRevRank`命令

> **作用**
>
> - 几乎与`ZRank`命令相同,只不过**`ZRevRank`命令**下元素的**元素分数越大**,元素的**排名越靠前**.而**`ZRank`**则是元素的**元素分数越小**,**排名越靠前.**

```shell
ZREVRANK 有序集合名 元素
```

****

### `ZRem`命令

> **作用**
>
> - 用于**移除**指定的一个有序集合中的指定**一个或一些元素**

```shell
ZREM 有序集合名 元素1 元素2 元素3
```

> **注意**
>
> - 若**有序集合不存在**,那么`ZREM`**不会做任何操作**,并**返回`0`**
> - 若我们制定都元素**并未全部出现**在有序集合中,那么**只会删除那些出现了的**元素,而**没有出现的**则会**忽略**,最终**返回成功从有序集合中删除的元素的数量**

### `ZRemRangeByRank`命令

> **作用**
>
> - 用于**删除**指定的一个有序集合中**排名在指定区间范围内的元素**(根据元素分数**从小到大排序**)

```shell
ZREMRANGEBYRANK 有序集合名 区间左值 区间右值
```

> **注意**
>
> - 删除是**根据闭区间来进行**的也就是`[区间左值,区间右值]`
> - 若**有序集合不存在**,那么**返回`0`**
> - 若我们指定的区间返回**不是有序集合元素排名的子集**,**不会发生报错**,只会**删除掉交集中的元素**,最终**返回成功从有序集合中删除掉的元素的数目**

### `ZRemRangeByScore`命令

> **作用**
>
> - 用于**删除**指定的一个有序集合中**元素分数**处于**指定区间范围内**的元素

```shell
ZREMRANGEBYSCORE 有序集合名 区间左值 区间右值
```

> **注意**
>
> - **默认情况下**删除的是元素分数**处于闭区间`[区间左值,区间右值]`中的元素**,但是我们可以**借助`(`来改变**这一行为
>     - 我们可以**通过**
>         - `(区间左值 区间右值`
>         - `(区间左值 (区间右值`
>         - `区间左值 (区间右值`
>     - 将**取值区间转变**为
>         - **左开右闭**`(区间左值,区间右值]`
>         - **开区间**`(区间左值,区间右值)`
>         - **左闭右开**`[区间左值,区间右值)`
> - **其他的注意点与`ZRemRangeByRank`命令的主注意点一致**

### `ZRemRangeByLex`命令

****

### `ZInterStore`命令

> **作用**
>
> - 用于获取指定的**两个或两个以上**的集合的**交集**,并将这个交集**存储到一个额外的有序集合中**

```shell
ZINTERSTORE 存储有序集合 要计算交集的有序集合数 有序集合1 有序集合2 有序集合3 [WEIGHT weiight1 weight2 weight3] [AGGREGATE SUM|MIN|MAX]
```

> **注意**
>
> - 默认情况下我们得到的**存储有序集合中**的每一个元素的**元素分数**是**每一个**用于做交集的有序集合中**该元素的元素分数的和**,但是借助`WEIGHT`和`AGGREGATE`可以**改变这一默认行为**
>     - **默认情况下**每一个有序集合的**权重为`1`**,**`AGGREGATE`为`SUM`**
>     - 通过**只改变`WEIGTH`**我们可以为每个有序集合**指定权重**,从而使得原来**简单的求和**变成**加权求和**
>     - 通过**只改变`AGGREGATE`**我们可以使得**原来的求和**变成取所有有序集合中该元素的**元素分数的最大值或者最小值**
>     - 如果**同时改变`AGGREGATE`和`WEIGHT`**那么效果为取所有有序集合中该元素的**加权元素分数的最大值或最小值**
>
> - **若存储集合已经存在,那么就会将这个集合清空,然后再进行存储操作**

### `ZUnionStore`命令

> **作用**
>
> - 几乎与`ZInterStore`相同,只不过**计算的是并集**而**非交集**

****

### `ZLexCount`命令

### `ZScan`命令

****

### `ZPopMax`命令

> **作用**
>
> - 用于获取并移除**指定的一个有序集合**中的**元素分数最大的前指定个元素及其元素分数**

```Shell
ZPOPMAX 有序集合名 最大获取的元素数目
```

> **注意**
>
> - 若**有序集合不存在**则**返回`empty array`**
> - 若有序集合中的**元素总数小于我们指定的最大获取元素数目**,那就**只会返回**整个有序集合中的**所有元素及它们的元素分数**,但**不会报错**

### `ZPopMin`命令

> **作用**
>
> - 与`ZPopMax`几乎相同,只不过返回的是**元素分数最小的前指定个元素及其元素分数**

```shell
ZPOPMIN 有序集合名 最大获取的元素数目
```

### `ZMPOP`命令

> **作用**
>
> - 用于获取指定的**一个或多个**有序集合中,**第一个非空有序集合**中的**前指定个最大或最小的元素及其元素分数**

```shell
ZMPOP 要给出的有序集合数 有序集合1 有序集合2 有序集合3 MIN|MAX [COUNT 最大获取的元素数目]
```

> **注意**
>
> - 获取的是第一个非空有序集合中的元素,如果我们指定的集合中第一个集合就是非空的,那么**后面给出的**集合即便非空也**会被忽略**
> - `MAX|MIN`**必须指定其中一个**,如果**不指定就会报错**
> - **`COUNT`默认值为`1`**

# `BitMap`位图数据类型

## `BitMap`位图数据类型特性介绍

- `BitMap`位图实际上**在`Redis`底层就是一个字符串**,只不过我们可以使用一系列的命令**修改或读取这个字符串的指定`bit`位**

<img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303051711853.png" alt="image-20230305171104529" style="zoom:80%;" />

## `BitMap`位图相关命令

### `SetBit`命令

> **作用**
>
> - 用于设置指定位图的指定`bit`位为`0|1`

```shell
SETBIT 位图名 bit位的索引 0|1
```

> **注意**
>
> - 若我们的位图中的`bit`位的**总数小于**我们**给出的`bit`位索引**,那么就会**用`0`来填充空位**的方式**将我们的位图的元素数扩充到我们给出的`bit位索引值+1`**,然后**再执行`SetBit`命令**
>
> - 若**位图不存在**就会**创建一个新的空位图**,然后**再执行`SetBit`命令**

### `GetBit`命令

> **作用**
>
> - 获取指定位图上的**指定`bit`位的索引位置的值**

```shell
GetBit 位图名 bit位的索引
```

> **注意**
>
> - 若**位图不存在**,那么**返回`0`**
> - 若给出的`bit`位的索引值**超出**了我们的位图的**区间范围**,那么**返回`0`**

### `BitCount`命令

> **作用**
>
> - 用于获取位图的**指定区间范围内中的`1`的数量**

```shell
BITCOUNT 位图名 [区间左值:bit位的索引] [区间右值:bit位的索引]
```

> **注意**
>
> - **区间左值**的**默认值为`0`**,**区间右值**的**默认值为`-1`**
> - 若**位图不存在**,那么任何操作都将**返回`0`**

### `BitPos`命令

> **作用**
>
> - 用于获取指定位图的**指定区间范围内**上的**第一个`0|1`出现的位置**的**`bit`位的索引值**

```shell
BITPOS 位图名 0|1 [区间左值:bit位的索引] [区间右值:bit位的索引]
```

> **注意**
>
> - **区间左值**的**默认值为`0`**,**区间右值**的**默认值为`-1`**
> - 若指定的区间范围内**根本就没有出现`0|1`**,那么**返回`-1`**
> - 若**位图不存在**,那么任何操作都将**返回`-1`**

### `BitOp`命令

> **作用**
>
> - 用于根据指定的**两个或两个以上**的位图进行**位运算**,并将位运算的结果**保存在指定的存储位图**中

```shell
BITOP [AND|OR|XOR] 存储位图名 位图1名 位图2名 位图3名
BITOP NOT 存储位图名 位图名
```

> **注意**
>
> - 若我们指定的用于位运算的位图的**长度不等**,那么`Redis`在进行运算时会**获取长度最大的位图的长度**,然后通过**用`0`来进行填充**的方式**将每一个位图填充成统一的长度**,然后**再进行`BitOp`命令**
> - 如果我们指定的用于位运算的位图中**有任何一个不存在**的,那么**其就会被视为全`0`的位图**来**参与运算**
> - 若我们的**存储位图已经存在**,那么就会将其清空然后**再进行存储**操作

# `HyperLogLog`基数统计数据类型

## `HyperLogLog`基数统计数据类型特性介绍



## `HyperLogLog`基数统计 数据类型相关命令

### `PFADD`命令

> **作用**
>
> - 用于给指定的基数统计中添加一个或多个元素

```shell
PFADD 基数统计名 元素1 元素2 元素3
```

> **注意**
>
> - 如果**基数统计不存在**,那么会先**构建一个空的基数统计**,然后**再执行`PFADD`**,`PFADD`执行完后会**返回`1`**
> - 如果我们添加的这些元素**都已经**被添加到我们的基数统计中了,那么**返回`0`**
> - 如果存在**至少一个**元素**成功添加**到了基数统计中,那么**返回`1`**

### `PFCOUNT`命令

> **作用**
>
> - 获取指定的**一个或多个**基数统计中**已添加的元素的数目**

```shell
PFCOUNT 基数统计1 基数统计2 基数统计3
```

> **注意**
>
> - 若指定的所有的基数统计**都不存在**,**返回`0`**
> - `PFCOUNT`的**返回值**是所有给定基数统计的**并集**中包含的**元素的数量**

### `PFMERGE`命令

> **作用**
>
> - 用于获取**两个或两个以上**的基数统计中包含的**元素的并集**,并将这个**并集存储**到另一个**存储基数统计中**

```shell
PFMERGE 存储基数统计 基数统计1 基数统计2 基数统计3
```

> **注意**
>
> - 若存储基数统计**已经存在**,那么就会**把它清空**,然后**再进行存储**

# `Geo`地理空间数据类型

## `Geo`地理空间数据类型特性介绍

- `Geo`地理空间数据类型实际上就是**一个特殊的`SortedSet`有序集合**
    - `SortedSet`有序集合可以存**一个整数或者浮点数**的`Score`,而`Geo`的`Score`是**经度和纬度两个值**

## `Geo`地理空间数据类型相关命令

### `GeoAdd`命令

> **作用**
>
> - 用于向指定地理空间中**存入一个或多个地理位置的经度,纬度,名称**

```Shell
GEOADD 地理空间名 经度1 纬度1 名称1 经度2 纬度2 名称2 经度3 纬度3 名称3
```

> **注意**
>
> - `Redis`的`Geo`地理空间数据类型是**会对我们给出的经度与纬度进行校验**的,如果它们**不在指定范围内**,只要**有一个不能通过校验**,我们的**整个`GeoAdd`命令就会失效回滚**
>     - <img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303052010814.png" alt="image-20230305201027702" style="zoom:67%;" />
> - 如果我们给定的**某个名称已经存储**在了我们的地理空间中,那么`GeoAdd`命令会**用**我们给出的**新的经纬度值覆盖原本的旧经纬度值.**
> - `GeoAdd`命令的返回值为**成功向地理空间中存入的名称数**,**不包括用于修改的名称**

### `GeoPos`命令

> **作用**
>
> - 用于从指定地理空间中根据指定的**一个或多个名称**分别获取它们**对应的经纬度**
>
> <img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303052018952.png" alt="image-20230305201834872" style="zoom:80%;" />

```shell
GEOPOS 地理空间名 名称1 名称2 名称3
```

> **注意**
>
> - 若某个名称**没有存储**在这个地理空间中,那么这个名称对应**获取到的值为`Nil`**
> - 若**地理空间不存在**则**返回值为`empty array`**

### `GeoDist`命令

> **作用**
>
> - 用于计算**指定的地理空间**中的**指定的两个名称之间**根据它们**经纬度计算出来的最短地理距离**

```shell
GEODIST 地理空间名 名称1 名称2 [m|km|mi|ft]
```

![image-20230305202336518](https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303052023595.png)

> **注意**
>
> - 若**地理空间不存在**或者**指定的两个名称中至少有一个并没有存储在地理空间**中,`GeoDist`命令的**返回值都为`Nil`**

### `GeoRadius`命令

> **作用**
>
> - 用于获取指定地理空间中**距离指定经纬度所对应的位置**的**距离满足指定要求**的**名称以及一些额外信息**

```Shell
GEORADIUS 地理空间 经度值 纬度值 距离值 m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT 最大获取的名称数]
```

<img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303052026003.png" alt="image-20230305202638899" style="zoom: 80%;" />

> **注意**
>
> - 若地理空间**不存在**或者**没有一个名称可以符合要求**,那么**返回值为`Nil`**
> - <img src="https://raw.githubusercontent.com/tangling0112/MyPictures/master/img/202303052029339.png" alt="image-20230305202914244" style="zoom: 80%;" />

### `GeoRadiusByMember`命令

> **作用**
>
> - 几乎与`GeoRadius`命令相同,只不过其**不是直接指定经纬度**,而**是指定地理空间中的名称**,除此以外**其他都相同**

```shell
GEORADIUS 地理空间 名称 距离值 m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT 最大获取的名称数]
```

> **注意**
>
> - 若地理空间**不存在**或者**给定名称并没有存储在这个地理空间**中又或者**地理空间中没有一个名称可以满足要求**,这三种情况的**返回值都为`Nil`**

### `GeoHash`命令

# `BitField`数据类型

## `BitField`数据类型特性介绍

## `BitField`数据类型相关命令

# `Stream`流数据类型

## `Stream`流数据类型特性介绍

## `Stream`流数据类型相关命令

